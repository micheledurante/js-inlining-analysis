# JavaScript Inlining Analysis
## Intro
- Start by watching the high-level description of the stages which V8 goes through to create machine code from JS code here https://v8.dev/blog/ignition-interpreter

- More slightly more detailed reference on how to understand V8 bytecode instructions can be found here https://fhinkel.rocks/2017/08/16/Understanding-V8-s-Bytecode

- Finally, a high-level description of the process from developer code to machine code in chromium-based browsers:<br>
    1. TS code
    1. TS code -> (TypeScript compiler) -> JS code 
    1. JS code -> (V8 Parser + Ignition interpreter) -> V8 bytecode 
    1. V8 bytecode -> (V8 TurboFan compiler) -> Machine code
    1. Machine code

## TL;DR
Is the practice of adding multiple const variables to expand inlined JS code only a matter of style, or does it also have performance implications?

This:
```js
function sum (obj) {
    const a = obj.a;
    const b = obj.b;
    return a + b;
}

let summed = sum({ a: 200, b: 100 });
```
Vs:
```js
function sum (obj) {
    return obj.a + obj.b;
}

let summed = sum({ a: 200, b: 100 });
```

Answer: ...

## Overview
The Intro roughly describes the intermediate steps TS code goes through, all the way to execution by a CPU. TS compilation (step no.2) is platform-independent as nodejs is used to ensure it. TS compilation is also executed in development/build environments only. Given a certain starting TS compiler version, we can assume that the output will be constant and we should not worry about this step too much. It will be the first transformative step our code will go through. I could not find any detailed references to any of the optimizations that might happen in this step, so I will examine the output JS code manually.

The compiled JS code is then fed into V8. This code will go through 2 major stages here, before execution: during the first stage, V8 will parse the given JS code and by the Ignition interpreter JS code will be turned into V8 bytecode. V8 bytecode represents a set on instructions used internally by V8 components and it logically represents the input JS code. Secondly, the TurboFan compiler will create platform-dependant, optimized machine instructions to be executed by the CPU. The V8 bytecode generated in first stage is platform-independent and its syntax follows conventions defined in V8 itself (see https://fhinkel.rocks/2017/08/16/Understanding-V8-s-Bytecode).

In order to be able to tell what exactly happens to JS code at runtime, the first stage of V8 that leads to the generation of bytecode is not enough as the second stage of compilation has a lot of optimizations that change the way instructions are executed. For our purpose, we will first analyse the bytecode and assess if further analysis of the compiled machine instructions is necessary to answer the question.

## JS Code Generated by the TypeScript Compiler
Given the following set up and TS code:
```bash
E:\git> node --version
v14.15.0
E:\git> npm --version
6.14.8
E:\git> tsc --version
Version 4.1.5
```
```ts
let obj = { a: 200, b: 100}

function sum(x, y) {
    return x + y;
}

const a = obj.a;
const b = obj.b;

let summed = sum(a, b);
```
We run:
```bash
tsc --target ES6 .\const.ts
```
Finally to get this compiled JS:
```js
let obj = { a: 200, b: 100 };
function sum(x, y) {
    return x + y;
}
const a = obj.a;
const b = obj.b;
let summed = sum(a, b);
```
Since:
> The var statement declares a function-scoped or globally-scoped variable, optionally initializing it to a value. [1]

I believe at this point that it is safe to assume the TS compiler did not inline/optimize the `const` declaration after compilation. The above JS code will request the creation of a variable named `b` and the assignment of the value `100` to it. This will cause the runtime to allocate the required memory in the JS heap.

In order to confirm this assumption, it is now worth analyzing the output of the V8 bytecode to confirm the assumptions.

## V8 Ignition Interpreter
These are the 2 versions of the same function, the second one being "inlined", with their respective V8 bytecode:
```js
function sum(obj) {
    const a = obj.a;
    const b = obj.b;
    return a + b;
}

let summed = sum({ a: 200, b: 100 });
```
```
[generated bytecode for function: sum (0x01e408211fad <SharedFunctionInfo sum>)]
Bytecode length: 16
Parameter count 2
Register count 2
Frame size 16
OSR nesting level: 0
Bytecode Age: 0
         000001E4082121B2 @    0 : 28 03 00 00       LdaNamedProperty a0, [0], [0]
         000001E4082121B6 @    4 : c6                Star0
         000001E4082121B7 @    5 : 28 03 01 02       LdaNamedProperty a0, [1], [2]
         000001E4082121BB @    9 : c5                Star1
         000001E4082121BC @   10 : 25 f9             Ldar r1
         000001E4082121BE @   12 : 35 fa 04          Add r0, [4]
         000001E4082121C1 @   15 : ab                Return
Constant pool (size = 2)
000001E408212181: [FixedArray] in OldSpace
 - map: 0x01e408042205 <Map>
 - length: 2
           0: 0x01e4080477bd <String[1]: #a>
           1: 0x01e408047859 <String[1]: #b>
```
- `LdaNamedProperty a0, [0], [0]`

    Loads the value of the property `#a` in the accumulator.

- `Star0`

    Stores the value from the accumulator to the registry 0.

- `LdaNamedProperty a0, [1], [2]`

    Loads the value of the property `#b` in the accumulator.

- `Star1`

    Stores the value from the accumulator to the registry 1.

- `Ldar r1`

    Loads the value stored in the registry 1 into the accumulator.

- `Add r0, [4]`

    Adds the value from registry 0 to the accumulator.

- `Return`

    Finally, return the the value in the accumulator.

```js
function sum(obj) {
    return obj.a + obj.b;
}

let summed = sum({ a: 200, b: 100 });
```
```
[generated bytecode for function: sum (0x023308211fad <SharedFunctionInfo sum>)]
Bytecode length: 13
Parameter count 2
Register count 1
Frame size 8
OSR nesting level: 0
Bytecode Age: 0
         00000233082121B2 @    0 : 28 03 00 01       LdaNamedProperty a0, [0], [1]
         00000233082121B6 @    4 : c6                Star0
         00000233082121B7 @    5 : 28 03 01 03       LdaNamedProperty a0, [1], [3]
         00000233082121BB @    9 : 35 fa 00          Add r0, [0]
         00000233082121BE @   12 : ab                Return
Constant pool (size = 2)
0000023308212181: [FixedArray] in OldSpace
 - map: 0x023308042205 <Map>
 - length: 2
           0: 0x0233080477bd <String[1]: #a>
           1: 0x023308047859 <String[1]: #b>
```
- `LdaNamedProperty a0, [0], [0]`

    Loads the value of the property `#a` in the accumulator.

- `Star0`

    Stores the value from the accumulator to the registry 0.

- `LdaNamedProperty a0, [1], [2]`

    Loads the value of the property `#b` in the accumulator.

- `Add r0, [4]`

    Adds the value from registry 0 to the accumulator.

- `Return`

    Finally, return the the value in the accumulator.

We can see that the second set instructions is 2 steps shorter: `Star1` and `Ldar r1`, one operation to store a value and an operation to read a value, are missing. This is because in the second case, by inlining the JS object properties, the interpreter can skip the middle part which is instead required by the non-inlined version of JS code.

The operations required to store first (with `Star1`) and load (with `Ldar`) the second property can be skipped as the final sum can be calculated while the second loaded value (`#b`) is still in the accumulator, avoiding the additional steps to store it and read it from the accumulator to the registry and back. This makes sense logically too: because of its verbosity, the non-inlined function needs more operations for achieving the same result. Verbosity was not in fact chosen based on performance considerations.

At this point it would seem clear that the gains from the verbosity of the non-inlined function come at a cost of additional operations at runtime: this is expected due to the additional statements introduced in the function that are not strictly related to the task th function is supposed to carry out.

Next, and last, step is to look a the optimized and unoptimized code that V8 TurboFan produces. As this is machine-level assembly, it is going to tell us if further optimizations take place to before the initial programmer's intentions are executed on the CPU.

## V8 TurboFan Compiler


References:<br>
[1] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var
